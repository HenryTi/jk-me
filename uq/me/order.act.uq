-- 每次处理最多maxActionRows行，然后退出，进入下一个循环。
-- 这样可以避免数据库被占用太多算力，以至于无法响应访问操作
CONST maxActionRows = 10;

ACT ActOrderAction ver 0.3 () {
    VAR orderActionId ID, rowCount INT = 0;
    SETTING 'orderActionId' BIGINT TO orderActionId;
    IF orderActionId IS NULL {
        SET orderActionId = 0;
    }
    FOR (VAR id ID, actionId ID, action ENUM EnumOrderAction
        , value DEC(18,4), item ENUM Item
        OF SELECT a.id, a.actionId, a.action, a.value, a.item
            FROM OrderAction as a
            WHERE a.id>orderActionId
            ORDER BY a.id ASC
            LIMIT maxActionRows)
    {
        IF action>=EnumOrderAction.orderMain {
            LOG CONCAT_WS(' ', action, id, actionId) SUBJECT 'OrderMainAction';
            FOR (VAR orderActionId ID
                OF SELECT a.id as orderActionId
                    FROM DxOrderAction as a
                    WHERE a.orderMain=actionId)
            {
                -- 处理跟这个订单相关的所有action
                -- LOG CONCAT_WS(' ', orderActionId) SUBJECT 'ACT ActOrderAction() FOR (VAR orderActionId ID';
                PROC ProcOrderAction(orderActionId);
            }
        }
        ELSE {
            -- LOG CONCAT_WS(' ', action, id, actionId) SUBJECT 'ACT ActOrderAction() action detail';
            PROC ProcOrderAction(id);
        }
        SET rowCount = rowCount+1;
        SETTING 'orderActionId' BIGINT = id;
    }

    IF rowCount>=maxActionRows {
        SCHEDULE ActOrderAction;
    }

};

PROC ProcOrderAction(
    orderActionId ID,
) {
    VAR orderMain ID OrderMain,
        orderDetail ID OrderDetail,             -- 如果0，则是针对Order主表
        actionId ID,                            -- deliver, receive, return detail id
        action ENUM EnumOrderAction,
        value DEC(18,4),
        item ENUM Item,
        done ENUM EnumDone,
        itemHistoryId ID;

    SET orderMain=a.orderMain
        , orderDetail=a.orderDetail
        , done=a.done
        FROM DxOrderAction as a WHERE a.id=orderActionId;    

    -- 表示没有DxOrderAction对应的内容。
    IF orderDetail IS NULL {
        set done=0;
        SET orderDetail=a.orderDetail FROM OrderAction as a WHERE a.id=orderActionId;
        SET orderMain=a.main FROM OrderDetail as a WHERE a.id=orderDetail;
        IF orderMain IS NULL {
            SET orderMain = 0;
        }
        WITH DxOrderAction as a ID=orderActionId
            SET a.orderMain=orderMain, a.orderDetail=orderDetail;
    }
    
    IF orderMain=0 {
        SET orderMain=a.main FROM OrderDetail as a WHERE a.id=orderDetail;
        IF orderMain IS NULL { RETURN; }
        WITH DxOrderAction as a ID=orderActionId SET a.orderMain=orderMain;
    }

    SET actionId=a.actionId, action=a.action, value=a.value, item=a.item 
        FROM OrderAction as a WHERE a.id=orderActionId;

    VAR readyStates ENUM ReadyStates;
    SET readyStates=a.readyStates FROM DxOrderMain as a WHERE a.id=orderMain;
    IF readyStates IS NULL {
        SET readyStates=ReadyStates.costNone;
    }

    VAR nDone ENUM EnumDone = done;
    LOG CONCAT_WS(' ', action, done, readyStates, orderActionId, orderActionId) SUBJECT 'readyStates&ReadyStates.cost';
    IF (readyStates&ReadyStates.cost)=ReadyStates.cost AND (done & EnumDone.withCost)=0 {
        LOG CONCAT_WS(' ', done, readyStates, orderActionId, orderActionId) SUBJECT '如果有成本';
        -- 如果有成本，Item.orderProfit History
        IF action=EnumOrderAction.deliverDone {
            PROC SaveItemProfit(actionId, orderDetail, value, itemHistoryId);
        }
        ELSEIF action=EnumOrderAction.receiveDone {
            PROC SaveItemReceive(actionId, orderDetail, value, itemHistoryId);
        }
        SET nDone = nDone | EnumDone.withCost;
    }
    IF (done & EnumDone.withoutCost)=0 {
        LOG CONCAT_WS(' ', done, readyStates, orderActionId, orderActionId) SUBJECT '如果没有成本';
        -- 如果没有成本，Item.orderAmount History
        IF action=EnumOrderAction.deliverDone {
            -- deliver的时候，生成orderAmount
            PROC SaveItemAmount(actionId, orderDetail, value, itemHistoryId);
        }
        ELSE {
            VAR create TIMESTAMP;
            SET create=b.[$create]
                FROM OrderDetail as a JOIN OrderMain as b ON a.main=b.id
                WHERE a.id=orderDetail;
            PROC SaveItemHistory(create, actionId, orderDetail, item, value, itemHistoryId);
        }
        SET nDone = nDone | EnumDone.withoutCost;
    }
    IF done<>nDone {
        WITH DxOrderAction as a ID=orderActionId SET a.done=nDone;
    }

    FOR (VAR post ENUM Post, to ID
        OF SELECT a.ix as post, a.xi as to
            FROM IxOrderBoundTo as a 
            WHERE a.ixx=orderMain
        )
    {
        VAR doneBound TINYINT, nDoneBound TINYINT;
        SET doneBound=a.done FROM IxOrderActionBoundPostDone as a WHERE a.ix=orderActionId AND a.xi=post;
        IF doneBound IS NULL { 
            SET doneBound=0;
        }
        ELSEIF doneBound=(EnumDone.withCost|EnumDone.withoutCost) {
            CONTINUE;
        }
        SET nDoneBound=doneBound;
        -- LOG CONCAT_WS(' ', post, to, readyStates, value, doneBound, nDoneBound) SUBJECT 'FOR BoundTo readyStates&ReadyStates.cost)=ReadyStates.cost AND (doneBound & EnumDone.withCost)=0';
        IF (readyStates&ReadyStates.cost)=ReadyStates.cost AND (doneBound & EnumDone.withCost)=0 {
            PROC ProcBoundPost(itemHistoryId, action, post, to, actionId, readyStates&ReadyStates.cost);
            SET nDoneBound = nDoneBound | EnumDone.withCost;
        }
        -- LOG CONCAT_WS(' ', post, to, readyStates, value, doneBound, nDoneBound) SUBJECT 'FOR BoundTo (doneBound & EnumDone.withoutCost)=0';
        IF (doneBound & EnumDone.withoutCost)=0 {
            PROC ProcBoundPost(itemHistoryId, action, post, to, actionId, readyStates&ReadyStates.costNone);
            SET nDoneBound = nDoneBound | EnumDone.withoutCost;
        }
        IF doneBound<>nDoneBound {
            WITH IxOrderActionBoundPostDone as a IX=orderActionId XI=post SET a.done=nDoneBound;
        }
    }
};

PROC ProcBoundPost (
    itemHistoryId ID,
    action ENUM EnumOrderAction, 
    post ENUM Post, 
    to ID, 
    actionId ID, 
    readyStates ENUM ReadyStates,        -- 15种ReadyStates，按位记
    -- value DEC(18,4),
) {
    -- LOG CONCAT_WS(' ', action, post, to, actionId, readyStates) SUBJECT 'ProcBoundPost Parameters';
    FOR (VAR item ENUM Item, itemToObj ENUM Item, ratio DEC(6,2), memo INT
        OF SELECT a.item, a.itemToObj, a.ratio, a.memo
            FROM PostBound as a LEFT JOIN ItemReadyStates as b ON a.item=b.id
            WHERE a.post=post AND a.action=action 
                AND IFNULL(b.readyStates, ReadyStates.costNone)=readyStates)
    {
        VAR hisItem ENUM Item, itemValue DEC(18,4), track ID, referer BIGINT;
        SET hisItem = a.item, itemValue = a.value, track = a.bizOp, referer = a.biz 
            FROM ItemHistory as a 
            WHERE a.id=itemHistoryId;
        IF hisItem <> item {
            LOG CONCAT_WS(' ', itemHistoryId, action, item, hisItem, itemToObj, referer, track) SUBJECT 'ProcBoundPost 1';
            -- 目前，只处理回溯一层。绝大多数情况下，应该是可以了
            -- 不能有分拆单的情况，比如某一个订单明细，分多次收款
            SET hisItem = NULL;
            SET itemHistoryId = b.id, hisItem = b.item, itemValue = b.value
                FROM IxActionTrack as a
                    JOIN ItemHistory as b ON a.xi=b.id
                WHERE a.ixx=action AND a.ix=referer AND b.item=item
                LIMIT 1;
            IF hisItem IS NULL OR hisItem <> item {
                LOG CONCAT_WS(' ', itemHistoryId, action, item, hisItem, itemToObj, referer, track) SUBJECT 'ProcBoundPost 2';
                BREAK;
            }
            WITH IxActionTrack IXX=action IX=referer XI=itemHistoryId DEL;
        }

        -- LOG CONCAT_WS(' ', itemHistoryId, item, itemToObj) SUBJECT 'ProcBoundPost PostItemHistory';
        VAR objectPostItemId ID = ID(ObjectPostItem new, to, post, itemToObj);
        WITH PostItemHistory as a IXX=objectPostItemId IX=itemHistoryId XI=0
            SET a.value=itemValue * IFNULL(ratio, 100) / 100, a.memo=memo;
    }
};

PROC SaveItemProfit(
    actionId ID,
    orderDetail ID,
    value DEC(18,4),
    out itemHistoryId ID,
) {
    VAR price DEC(18,4), cost DEC(18,4), create TIMESTAMP;
    SET price=a.price, create=b.[$create]
        FROM OrderDetail as a JOIN OrderMain as b ON a.main=b.id
        WHERE a.id=orderDetail;
    SET cost=a.costPrice FROM DxOrderDetail as a WHERE a.id=orderDetail;
    PROC SaveItemHistory(create, actionId, orderDetail, Item.orderProfit, (price-cost)*value, itemHistoryId);
    LOG CONCAT_WS(' ', EnumOrderAction.receiveDone, orderDetail, itemHistoryId) SUBJECT 'SaveItemProfit IxActionTrack';
    WITH IxActionTrack IXX=EnumOrderAction.receiveDone IX=orderDetail XI=itemHistoryId;
};

PROC SaveItemAmount(
    actionId ID,
    orderDetail ID,
    value DEC(18,4),
    out itemHistoryId ID,
) {
    -- LOG CONCAT_WS(' ', actionId, orderDetail, value) SUBJECT 'SaveItemAmount' 1;
    VAR price DEC(18,4), create TIMESTAMP;
    SET price=a.price, create=b.[$create]
        FROM OrderDetail as a JOIN OrderMain as b ON a.main=b.id
        WHERE a.id=orderDetail;
    PROC SaveItemHistory(create, actionId, orderDetail, Item.orderAmount, price*value, itemHistoryId);
};

PROC SaveItemReceive(
    actionId ID,
    orderDetail ID,
    value DEC(18,4),
    out itemHistoryId ID,
) {
    LOG CONCAT_WS(' ', actionId, orderDetail, value) SUBJECT 'SaveItemReceive';
    PROC SaveItemHistory(NULL, actionId, orderDetail, Item.orderReceive, value, itemHistoryId);
};

PROC SaveItemHistory ver 0.1 (
    create TIMESTAMP,
    actionId ID,
    orderDetail ID,
    item ENUM Item,
    value DEC(18,4),
    out itemHistoryId ID,
) {
    -- LOG CONCAT_WS(' ', actionId, item, value) SUBJECT 'SaveItemHistory' 2;
    SET itemHistoryId = ID(ItemHistory new, actionId, item, create);
    WITH ItemHistory as a ID = itemHistoryId SET a.value=value, a.biz=orderDetail, a.bizOp=actionId;
};
