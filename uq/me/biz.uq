-- 每次处理最多maxActionRows行，然后退出，进入下一个循环。
-- 这样可以避免数据库被占用太多算力，以至于无法响应访问操作
CONST maxActionRows = 10;

-- BizMain ready, 加入这个队列
ID # QueueBizMain MINUTEID (
    id,
    KEY bizMain ID,                     -- bizMain
);

ID # QueueBizOp MINUTEID (
    id,
    KEY bizOp ID,                       -- detail of deliver, receive, return
);

-- biz是核心
IDX DxBiz ver 0.7 (
    id,
    main ID,
    ready TINYINT DEFAULT 0,
    sys (create, update),
    INDEX main_id(main, id) UNIQUE,
);

-- BizOp是针对Biz的业务操作
IDX DxBizOp (
    id,                                 -- bizOp id
    type ENUM EnumBizOpType,
    biz ID,                             -- 指向biz
    value DEC(18,4),
    done TINYINT DEFAULT 0,             -- 1: done
    stamp INT,
    sys (create, update),
    INDEX biz_id(biz),
);

-- 标记bizOp/BizMainBound相关的绩效是否已经已经写入opiHistory,bound = 1表示已经处理，是操作结果,不是输入；
IX IxBizOpBound (
    ix,                                 -- bizOp id
    xi BizMainBound,
    bound TINYINT DEFAULT 0,            -- 1: bound
    opiItemHistory TINYINT DEFAULT 0,   -- 1: On OpiItemHistory
    sys (create, update),
);

ID #BizopOfDuplicateOpiHistory MINUTEID (
    id,
    itemHistoryId ID,
    bizOp ID,
    booking ID,
    bizMainBoundId ID,
);

-- 1. bizMain跟岗位和个人以及“科目item”的绑定关系，表示该bizMain将使用该item为该岗位的该个人计算绩效
-- 2. 从订单绑定管理发送过来。
-- 3. 一直保留
ID #BizMainBound (
    id,
    KEY bizMain ID,
    KEY post ENUM Post,
    KEY item ENUM Item,
    KEY to ID,
    ratio DEC(6,2),
    sys (create),
);

-- 处理的是 biz main sheet
PROC # ExecQueueBizMain ver 0.4 () {
    /-mysql
  	DECLARE _$ERROR TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN
        GET DIAGNOSTICS CONDITION 1 _$error = MESSAGE_TEXT;
        ROLLBACK;
        UPDATE `tv_$queue_act` SET `running`=0 
            WHERE `entity`=(SELECT `id`
            FROM `tv_$entity` 
            WHERE 1=1 AND `name`='execqueuebizmain');
        CALL `$uq`.`log`(0,'me', concat('Schedule ExecQueueBizMain Error bizMain=', _bizmain_2),_$error);
        RESIGNAL;
    END;
    -/
    LOG CONCAT_WS('ExecQueueBizMain ', 'start') SUBJECT 'Schedule ExecQueueBizMain';
    VAR queueId ID, bizMain ID, tick INT, compileTick INT;
    VAR rows INT;
    SET rows=0;
    SET tick=UNIX_TIMESTAMP();
    WHILE 1=1 {
        VAR tickBizOp INT = UNIX_TIMESTAMP();
        SET queueId = NULL;
        SET queueId=a.id, bizMain=a.bizMain
            FROM QueueBizMain as a
            ORDER BY a.id ASC
            LIMIT 1;
        IF queueId IS NULL {
            LOG CONCAT_WS(' ', NULL) SUBJECT 'Schedule ExecQueueBizMain EXIT';
            RETURN;
        }
        -- DxBizOp.done = 0 write item history
        FOR (VAR bizOp ID, done TINYINT
            OF SELECT c.id as bizOp, c.done
                FROM DxBiz as b
                    JOIN DxBizOp as c ON c.biz=b.id
                WHERE b.main=bizMain AND b.ready=1)
        {
            IF done=0 OR EXISTS (
                SELECT b.id
                    FROM DxBizOp as b
                        JOIN DxBiz as d ON d.id=b.biz
                        JOIN BizMainBound as e ON e.bizMain=d.main
                        LEFT JOIN IxBizOpBound as f ON f.ix=b.id AND f.xi=e.id
                    WHERE f.bound IS NULL 
                        OR f.bound=0
                        OR f.opiItemHistory IS NULL
                        OR f.opiItemHistory=0
            )
            {
                WITH QueueBizOp as a ID=bizOp SET a.bizop=bizOp;
            }
        }
        WITH QueueBizMain ID=queueId DEL;
        LOG CONCAT(rows, ' ', UNIX_TIMESTAMP()-tickBizOp, 's bizMain ', bizMain) SUBJECT 'Schedule ExecQueueBizMain';
        SET rows = rows + 1;
        IF rows>10 {
            SETTING 'compileTick' CHAR TO compileTick;
            IF tick<IFNULL(compileTick, 0) {
                BREAK;
            }
            ELSE {
                SLEEP Const_Sleep_Time;
            }
            SET rows = 0;
        }
    }
    LOG CONCAT_WS('ExecQueueBizMain ', 'end because compile') SUBJECT 'Schedule ExecQueueBizMain';
};

PROC #ExecQueueBizOp ver 0.4 () {
    /-mysql
  	DECLARE _$ERROR TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN
        GET DIAGNOSTICS CONDITION 1 _$error = MESSAGE_TEXT;
        ROLLBACK;
        UPDATE `tv_$queue_act` SET `running`=0 
            WHERE `entity`=(SELECT `id`
            FROM `tv_$entity` 
            WHERE 1=1 AND `name`='execqueuebizop');
        CALL `$uq`.`log`(0,'me','Schedule ExecQueueBizOp Error',_$error);
        RESIGNAL;
    END;
    -/
    LOG CONCAT_WS('ExecQueueBizOp ', 'start') SUBJECT 'Schedule ExecQueueBizOp';
    VAR queueId ID, bizOp ID, rows INT, tick INT, compileTick INT;
    SET rows=0;
    SET tick=UNIX_TIMESTAMP();
    WHILE 1=1 {
        SET queueId=NULL;
        SET queueId=a.id, bizOp=a.bizOp
            FROM QueueBizOp as a
            ORDER BY a.id ASC
            LIMIT 1;
        IF queueId IS NULL {
            BREAK;
        }
        VAR tickBizOp INT = UNIX_TIMESTAMP();
        TRANSACTION Start;
        PROC ProcBizOp(bizOp);
        WITH QueueBizOp ID=queueId DEL;
        TRANSACTION Commit;
        SET rows = rows + 1;

        LOG CONCAT(rows, ' '
            , UNIX_TIMESTAMP()-tickBizOp
            , 'ms bizOp ', bizOp
        ) SUBJECT 'Schedule ExecQueueBizOp';
        IF rows>=10 {
            SETTING 'compileTick' CHAR TO compileTick;
            IF tick<IFNULL(compileTick, 0) {
                BREAK;
            }
            ELSE {
                SLEEP Const_Sleep_Time;
            }
            SET rows=0;
        }
    }
    LOG CONCAT_WS('ExecQueueBizOp ', 'end because compile') SUBJECT 'Schedule ExecQueueBizOp';
};

PROC #ProcBizOp ver 0.1 (
    bizOp ID,
) {
    -- 判断是不是Biz的凭单已经ready
    IF NOT Exists(SELECT b.id
        FROM DxBizOp as a 
            JOIN DxBiz as b ON b.id=a.biz
            -- JOIN DxBizMain as c ON c.id=b.main
        WHERE a.id=bizOp AND b.ready=1
    )
    {
        RETURN;
    };

    VAR bizOpType ENUM EnumBizOpType, done TINYINT, biz ID, opi ID, changed TINYINT;
    VAR ixOpiItemHistoryId ID;
    SET bizOpType=a.type, done=a.done, biz=a.biz
        FROM DxBizOp as a 
        WHERE a.id=bizOp;

    IF done=0 {
        PROC ProcWriteItemHistory(bizOp);
        WITH DxBizOp ID=bizOp SET done=1;
    }

    -- biz bound post history
    LOG CONCAT_WS(' ', 'bizOpType', bizOpType, 'biz', biz, 'bizOp', bizOp) SUBJECT 'ProcBizOp';
    FOR (VAR booking ID, itemHistoryId ID, post ENUM Post, stamp INT, value DEC(18,4)
        , postItem ENUM Item, ratio DEC(6,2)
        , to ID, bizMainBoundId ID, boundRatio DEC(6,2)
        , opBound TINYINT, boundOpiItemHistory ID
        OF SELECT a.id as booking, c.id as itemHistoryId, a.post, b.stamp
            , c.value, a.postItem, a.ratio
            , e.to, e.id as bizMainBoundId, e.ratio as boundRatio
            , f.bound as opBound, f.opiItemHistory as boundOpiItemHistory
            FROM OPIBooking as a
                JOIN DxBizOp as b ON a.bizOpType=b.type
                JOIN ItemHistory as c ON c.item=a.item AND c.bizOp=b.id
                JOIN DxBiz as d ON d.id=b.biz
                JOIN BizMainBound as e ON e.bizMain=d.main AND e.post=a.post AND e.item=a.postItem
                LEFT JOIN IxBizOpBound as f ON f.ix=b.id AND f.xi=e.id
            WHERE b.id=bizOp)
    {
        SET changed = 0;
        IF boundOpiItemHistory IS NULL OR boundOpiItemHistory = 0 {
            SET opi = ID(
                ObjectPostItem new
                KEY object=to, post=post, item=postItem
            );
            LOG CONCAT_WS(' ', opi, itemHistoryId, bizOpType, post, postItem, to) SUBJECT 'ProcBizOp Bound 1';
            -- write OpiItemHistory
            VAR opiItemHistoryId ID;
            SET opiItemHistoryId=ID(
                ItemHistory new 
                KEY bizOp=itemHistoryId, item=postItem
                STAMP stamp
            );
            WITH ItemHistory as a ID=opiItemHistoryId
                SET a.value=value * IFNULL(IFNULL(boundRatio, ratio), 100) / 100
                    , a.booking=booking;
            WITH OPIItemHistory IX=opi XI=opiItemHistoryId ID TO ixOpiItemHistoryId;
            WITH IxBizOpBound IX=bizOp XI=bizMainBoundId SET opiItemHistory=1;
            WITH SumQueueItemHistory ID=itemHistoryId;
            QUEUE QueueSumOpiItemHistory ADD ixOpiItemHistoryId;
            SET changed = 1;
        }

        IF opBound IS NULL OR opBound = 0 {
            SET opi = ID(
                ObjectPostItem new
                KEY object=to, post=post, item=postItem
            );
            IF Exists(SELECT a.id FROM OPIHistory as a WHERE a.opi=opi AND a.itemHistory=itemHistoryId AND a.booking=booking) {
                VAR bdoId ID = ID(BizopOfDuplicateOpiHistory new);
                WITH BizopOfDuplicateOpiHistory as a ID=bdoId SET 
                    a.itemHistoryId = itemHistoryId,
                    a.bizOp = bizOp,
                    a.booking = booking,
                    a.bizMainBoundId = bizMainBoundId;
                CONTINUE;
            }
            -- to be deleted
            -- write OpiHistory
            VAR opiHistoryId ID;
            SET opiHistoryId=ID(OPIHistory new STAMP stamp);
            LOG CONCAT_WS(' ', opi, opiHistoryId, bizOpType, post, postItem, to) SUBJECT 'ProcBizOp Bound 1';
            WITH OPIHistory as a ID=opiHistoryId
                SET a.opi=opi, a.itemHistory=itemHistoryId
                , a.value=value * IFNULL(IFNULL(boundRatio, ratio), 100) / 100
                , a.booking=booking;
            WITH IxBizOpBound IX=bizOp XI=bizMainBoundId SET bound=1;
            WITH SumQueueOpiHistory ID=opiHistoryId;
            SET changed = 1;
        }
        
        IF changed=0 {
            CONTINUE;
        }
        FOR (VAR user ID
            OF SELECT b.ix as user
                FROM ObjectPostItem as a JOIN UserObject as b ON a.object=b.xi
                WHERE a.id=opi)
        {
            POKE user;
        }
    }
};

-- 这个是需要根据不同的业务，调整代码的。目前无法直接用表达式实现
-- 如果要记orderProfit和orderAmount，必须有orderDeliverDone操作。
-- 如果先收到orderReceiveDone，先记receive账。
PROC #ProcWriteItemHistory ver 0.1 (
    bizOp ID,
) {
    VAR biz ID, bizOpType ENUM EnumBizOpType, value DEC(18,4);
    VAR itemHistoryId ID;
    VAR price DEC(18,4), margin DEC(18,4);
    SET biz=a.biz, bizOpType=a.type, value=a.value
        FROM DxBizOp as a 
        WHERE a.id=bizOp;

    IF bizOpType=EnumBizOpType.orderDeliverDone or bizOpType = EnumBizOpType.orderReturn {
        VAR mainItem ENUM Item;
        SET mainItem = Item.orderAmount;
        if bizOpType = EnumBizOpType.orderReturn
            SET mainItem = Item.orderReturn;

        VAR orderType ENUM OrderType, currency ENUM EnumCurrency
            , baseCurrencyPrice DEC(18,4), baseCurrencyMargin DEC(18,4), rate DEC(18,4);
        SET orderType=a.type, currency=a.currency, rate=d.rate
            FROM OrderMain as a 
                JOIN DxBiz as b ON b.main=a.id
                JOIN DxBizOp as c ON c.biz=b.id
                LEFT JOIN DxCurrency as d ON d.id=a.currency
            WHERE c.id=bizOp;
        SET price=a.price
            FROM OrderDetail as a
            WHERE a.id=biz;
        IF currency IS NULL {
            SET baseCurrencyPrice=price;
            SET baseCurrencyMargin=margin;
        }
        ELSE {
            SET baseCurrencyPrice=price * rate;
            SET baseCurrencyMargin=margin*rate;
        }
        
        SET margin=a.margin FROM DxOrderDetail as a WHERE a.id=biz;
        -- 可能是积分兑换单引发的deliver-done，这时候，就没有margin和price，所以不写帐
        IF price IS NOT NULL AND price > 0 {
            IF orderType=OrderType.Customer {
                PROC ProcItemHistory(bizOp, mainItem, baseCurrencyPrice*value, itemHistoryId);
                IF currency IS NOT NULL {
                    WITH CurrencyItemHistory as a ID=itemHistoryId SET a.currency=currency, a.value=price*value, a.rate=rate;
                }
                PROC ProcItemHistory(bizOp, Item.orderProfit, (baseCurrencyMargin)*value, itemHistoryId);
                PROC ProcItemHistory(bizOp, Item.orderFee, (baseCurrencyMargin)*value, itemHistoryId);
            }
            ELSEIF orderType=OrderType.SaleBranch {
                PROC ProcItemHistory(bizOp, Item.orderSaleTransferIn, baseCurrencyPrice*value, itemHistoryId);
                PROC ProcItemHistory(bizOp, Item.orderSaleTransferOut, baseCurrencyPrice*value, itemHistoryId);
            }
            ELSEIF orderType=OrderType.FactoryBranch {
                PROC ProcItemHistory(bizOp, Item.orderFactoryTransferIn, baseCurrencyPrice*value, itemHistoryId);
                PROC ProcItemHistory(bizOp, Item.orderFactoryTransferOut, baseCurrencyPrice*value, itemHistoryId);
            }
        }
        ELSE {
            LOG CONCAT_WS(' ', bizOp, bizOpType, price, margin, value) SUBJECT 'Failed BizOp ItemHistory Price IS NULL';
        }
    }
    ELSEIF bizOpType=EnumBizOpType.orderReceiveDone {
        PROC ProcItemHistory(bizOp, Item.orderReceive, value, itemHistoryId);
        SET price=a.price
            FROM OrderDetail as a
            WHERE a.id=biz;
        SET margin=a.margin FROM DxOrderDetail as a WHERE a.id=biz;
        -- 可能是积分兑换单引发的deliver-done，这时候，就没有margin和price，所以不写帐
        IF price IS NOT NULL AND price > 0 {
            PROC ProcItemHistory(bizOp, Item.orderFee, 
                CASE WHEN price<0.01 THEN 0 ELSE (margin)/price*value END, itemHistoryId);
        }
        ELSE {
            LOG CONCAT_WS(' ', bizOp, bizOpType, price, margin, value) SUBJECT 'Failed BizOp ItemHistory Price IS NULL';
        }
    }
};

PROC #ProcItemHistory ver 0.1 (
    bizOp ID,
    item ENUM Item,
    value DEC(18,4),
    out itemHistoryId ID,
) {
    VAR stamp INT, booking ID, type ENUM EnumBizOpType;
    SET itemHistoryId = a.id FROM ItemHistory as a WHERE a.bizOp=bizOp AND a.item=item;
    SET type = a.type, stamp = a.stamp FROM DxBizOp as a WHERE a.id=bizOp;
    IF itemHistoryId IS NULL {
        SET itemHistoryId = ID(
            ItemHistory new
            KEY bizOp=bizOp, item=item
            STAMP stamp
        );
        SET booking = a.id FROM OPIBooking as a 
            WHERE a.bizOpType=type AND a.post=Post.sys AND a.postItem=item AND a.item=item;
        WITH ItemHistory as a ID = itemHistoryId SET a.value=value, a.booking=booking;
        WITH SumQueueItemHistory ID=itemHistoryId;
    }
};
