-- 每次处理最多maxActionRows行，然后退出，进入下一个循环。
-- 这样可以避免数据库被占用太多算力，以至于无法响应访问操作
CONST maxActionRows = 10;

-- BizMain ready, 加入这个队列
ID # QueueBizMain MINUTEID (
    id,
    KEY bizMain ID,                     -- bizMain
);

ID # QueueBizOp MINUTEID (
    id,
    KEY bizOp ID,                       -- detail of deliver, receive, return
);

IDX # DxBizMain (
    id,
    ready INT DEFAULT 0,                -- ready状态
    sys (create, update),
);

-- biz是核心
IDX # DxBiz (
    id,
    main ID,
    sys (create, update),
    INDEX main_id(main),
);

-- BizOp是针对Biz的业务操作
IDX # DxBizOp (
    id,                                 -- bizOp id
    type ENUM EnumBizOpType,
    biz ID,                             -- 指向biz
    value DEC(18,4),
    done TINYINT DEFAULT 0,             -- 1: done
    stamp INT,
    sys (create, update),
    INDEX biz_id(biz),
);

-- 标记BizMainBound是否已经处理,bound = 1表示已经处理，是操作结果,不是输入；
IX # IxBizOpBound (
    ix,                         -- bizOp id
    xi BizMainBound,
    bound TINYINT DEFAULT 0,    -- 1: bound
    sys (create, update),
);

-- 1. bizMain跟岗位和个人以及“科目item”的绑定关系，表示该bizMain将使用该item为该岗位的该个人计算绩效
-- 2. 从订单绑定管理发送过来。
-- 3. 一直保留
ID #BizMainBound (
    id,
    KEY bizMain ID,
    KEY post ENUM Post,
    KEY item ENUM Item,
    KEY to ID,
    ratio DEC(6,2),
    sys (create),
);

-- 处理的是 biz main sheet
ACT # ExecQueueBizMain () {
    VAR queueId ID, bizMain ID;
    SET queueId=a.id, bizMain=a.bizMain
        FROM QueueBizMain as a
        ORDER BY a.id ASC
        LIMIT 1;
    IF queueId IS NULL {
        LOG CONCAT_WS(' ', NULL) SUBJECT 'ExecQueueBizMain EXIT';
        RETURN;
    }
    LOG CONCAT_WS(' ', bizMain, queueId) SUBJECT 'ExecQueueBizMain';
    FOR (VAR bizOp ID
        OF SELECT c.id as bizOp
            FROM DxBiz as b
                JOIN DxBizOp as c ON c.biz=b.id
            WHERE b.main=bizMain)
    {
        TRANSACTION Start;
        PROC ProcBizOp(bizOp);
        TRANSACTION Commit;
    }
    WITH QueueBizMain ID=queueId DEL;
    SCHEDULE ExecQueueBizMain;
};

ACT #ExecQueueBizOp ver 0.3 () {
    LOG CONCAT_WS(' ', 'start') SUBJECT 'ExecQueueBizOp';
    VAR rowCount INT = 0;
    FOR (VAR queueId ID, bizOp ID
        OF SELECT a.id as queueId, a.bizOp
            FROM QueueBizOp as a
            ORDER BY a.id ASC
            LIMIT maxActionRows)
    {
        LOG CONCAT_WS(' ', 'bizOp', bizOp) SUBJECT 'ExecQueueBizOp';
        TRANSACTION Start;
        PROC ProcBizOp(bizOp);
        WITH QueueBizOp ID=queueId DEL;
        TRANSACTION Commit;
        SET rowCount = rowCount + 1;
    }

    IF rowCount>=maxActionRows {
        SCHEDULE ExecQueueBizOp;
    }
};

PROC #ProcBizOp(
    bizOp ID,
) {
    -- 判断是不是Biz的凭单已经ready
    IF NOT Exists(SELECT c.id
        FROM DxBizOp as a 
            JOIN DxBiz as b ON b.id=a.biz
            JOIN DxBizMain as c ON c.id=b.main
        WHERE a.id=bizOp AND c.ready=1)
    {
        RETURN;
    };

    VAR bizOpType ENUM EnumBizOpType, done TINYINT, biz ID;
    SET bizOpType=a.type, done=a.done, biz=a.biz
        FROM DxBizOp as a 
        WHERE a.id=bizOp;

    IF done=0 {
        PROC ProcWriteItemHistory(bizOp);
        WITH DxBizOp ID=bizOp SET done=1;
    }

    -- biz bound post history
    LOG CONCAT_WS(' ', 'bizOpType', bizOpType, 'biz', biz, 'bizOp', bizOp) SUBJECT 'ProcBizOp';
    FOR (VAR booking ID, itemHistoryId ID, post ENUM Post, stamp INT, value DEC(18,4)
        , postItem ENUM Item, ratio DEC(6,2)
        , to ID, bizMainBoundId ID, boundRatio DEC(6,2)
        OF SELECT a.id as booking, c.id as itemHistoryId, a.post, b.stamp
            , c.value, a.postItem, a.ratio
            , e.to, e.id as bizMainBoundId, e.ratio as boundRatio
            FROM OPIBooking as a
                JOIN DxBizOp as b ON a.bizOpType=b.type
                JOIN ItemHistory as c ON c.item=a.item AND c.bizOp=b.id
                JOIN DxBiz as d ON d.id=b.biz
                JOIN BizMainBound as e ON e.bizMain=d.main AND e.post=a.post AND e.item=a.postItem
                LEFT JOIN IxBizOpBound as f ON f.ix=b.id AND f.xi=e.id
            WHERE b.id=bizOp AND f.bound IS NULL)
    {
        -- LOG CONCAT_WS(' ', 'action', action, itemHistoryId, post, postItem, to) SUBJECT 'ProcBizOp Bound 1';
        VAR objectPostItemId ID = ID(
            ObjectPostItem new
            KEY object=to, post=post, item=postItem
        );
        LOG CONCAT_WS(' ', objectPostItemId, itemHistoryId, bizOpType, post, postItem, to) SUBJECT 'ProcBizOp Bound 2';
        VAR opiHistoryId ID;
        SET opiHistoryId=ID(OPIHistory new STAMP stamp);
        WITH OPIHistory as a ID=opiHistoryId
            SET a.opi=objectPostItemId, a.itemHistory=itemHistoryId
            , a.value=value * IFNULL(IFNULL(boundRatio, ratio), 100) / 100
            , a.booking=booking;
        FOR (VAR user ID
            OF SELECT b.ix as user
                FROM ObjectPostItem as a JOIN UserObject as b ON a.object=b.xi
                WHERE a.id=objectPostItemId)
        {
            POKE user;
        }
        WITH IxBizOpBound IX=bizOp XI=bizMainBoundId SET bound=1;
    }
};

-- 这个是需要根据不同的业务，调整代码的。目前无法直接用表达式实现
-- 如果要记orderProfit和orderAmount，必须有orderDeliverDone操作。
-- 如果先收到orderReceiveDone，先记receive账。
PROC #ProcWriteItemHistory ver 0.1 (
    bizOp ID,
) {
    VAR biz ID, bizOpType ENUM EnumBizOpType, value DEC(18,4);
    VAR price DEC(18,4), cost DEC(18,4); -- , stamp INT;
    SET biz=a.biz, bizOpType=a.type, value=a.value -- , stamp=stamp; 
        FROM DxBizOp as a 
        WHERE a.id=bizOp;
    IF bizOpType=EnumBizOpType.orderDeliverDone {
        SET price=a.price
            FROM OrderDetail as a
            WHERE a.id=biz;
        SET cost=a.costPrice FROM DxOrderDetail as a WHERE a.id=biz;
        -- 可能是积分兑换单引发的deliver-done，这时候，就没有cost和price，所以不写帐
        IF price IS NOT NULL AND price > 0 {
            PROC ProcItemHistory(bizOp, Item.orderAmount, price*value);
            IF cost IS NOT NULL {
                PROC ProcItemHistory(bizOp, Item.orderProfit, (price-cost)*value);
                PROC ProcItemHistory(bizOp, Item.orderFee, (price-cost)*value);
            }
            ELSE {
                LOG CONCAT_WS(' ', bizOp, bizOpType, price, cost, value) SUBJECT 'Failed BizOp ItemHistory Cost IS NULL';
            }
        }
        ELSE {
            LOG CONCAT_WS(' ', bizOp, bizOpType, price, cost, value) SUBJECT 'Failed BizOp ItemHistory Price IS NULL';
        }
    }
    ELSEIF bizOpType=EnumBizOpType.orderReceiveDone {
        PROC ProcItemHistory(bizOp, Item.orderReceive, value);
        SET price=a.price
            FROM OrderDetail as a
            WHERE a.id=biz;
        SET cost=a.costPrice FROM DxOrderDetail as a WHERE a.id=biz;
        -- 可能是积分兑换单引发的deliver-done，这时候，就没有cost和price，所以不写帐
        IF price IS NOT NULL AND price > 0 {
            IF cost IS NOT NULL {
                PROC ProcItemHistory(bizOp, Item.orderFee, 
                    CASE WHEN price<0.01 THEN 0 ELSE (price-cost)/price*value END);
            }
            ELSE {
                LOG CONCAT_WS(' ', bizOp, bizOpType, price, cost, value) SUBJECT 'Failed BizOp ItemHistory Cost IS NULL';
            }
        }
        ELSE {
            LOG CONCAT_WS(' ', bizOp, bizOpType, price, cost, value) SUBJECT 'Failed BizOp ItemHistory Price IS NULL';
        }
    }
    ELSEIF bizOpType=EnumBizOpType.orderReturn {

    }
};

PROC #ProcItemHistory(
--    biz ID,
    bizOp ID,
    item ENUM Item,
    value DEC(18,4),
--    stamp INT,
) {
    VAR itemHistoryId ID, stamp INT;
    SET itemHistoryId = a.id FROM ItemHistory as a WHERE a.bizOp=bizOp AND a.item=item;
    SET stamp = a.stamp FROM DxBizOp as a WHERE a.id=bizOp;
    IF itemHistoryId IS NULL {
        SET itemHistoryId = ID(
            ItemHistory new
            KEY bizOp=bizOp, item=item
            STAMP stamp
        );
        WITH ItemHistory as a ID = itemHistoryId SET a.value=value; -- , a.bizOp=bizOp;
    }
};
